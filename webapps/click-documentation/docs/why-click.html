<!DOCTYPE' HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
 "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
 <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
 <meta name="Author" content="Malcolm Edgar"/>
 <link rel="stylesheet" type="text/css" href="../help.css"/>
</head>
<body>
  
<h1>Why Click</h1>
<p/>
This topic discusses the design philosophy and background behind Click, and hopefully explains why someone would build
another Java web application framework.
<p>&nbsp;</p>


Click is modern J2EE web application framework, which incorporates lessons learned from previous frameworks including 
Struts and Tapestry. &nbsp; Key features of Click include:

<h2>Simple to Learn</h2>
Click is designed to be simple learn so that new developers can get up and running in a day.  This is very important 
with commercial development teams where you have a wide range of skill levels and motivation.
<p/>
My experience introducing Tapestry (2.3) to development teams was that it is too complex and difficult to learn for 
average developer. The two development teams I introduced to Tapestry eventually dropped it and revert to Struts.
<p/>
Click is also significantly easier to learn than Struts. The Struts framework, while essentially a simple command 
pattern design, has quite a convoluted and confusing design. 
<p/>
To support ease of adoption Click has some of the best documentation for available for a open source framework and 
includes many working examples.
<p/>

<h2>Component and Page Oriented Design</h2>
If you have done traditional GUI programming with Swing, VB or Delphi you will know that there is something very wrong
with J2EE web development. J2EE web development is painfully slow, complex and error prone.
<p/>
One of the first generation J2EE web frameworks was Struts, which provides a command pattern design and a set of JSP 
tag libs. Unfortunately with Struts you are still down in the weeds, mapping URLs to Actions working with primitive 
ActionForms.  Its not giving you much leverage at all.
<p/>
Tapestry was one of first the component base J2EE web frameworks, introducing the component hierarchies, pages and an 
event based programming model.  This is a much more productive way of working, and is what we have come to expect in 
when developing desktop GUI applications.  
<p/>
The idea with Click was to take this page and component design approach, and make it much easiser to use and more 
accessable.
<p/>
Click provides an Page oriented design, featuring Control components and an event based programming model. Click 
includes 22 Controls out of the box, which correspond to the major HTML elements. It's a great way of programming 
more simply.
<p/>
Click Forms and Controls provide automatic validation and rendering, making form development very fast and robust.

<h2>JSP & MVC Free</h2>
Click is JSP Free. This is a good thing! 
<p/>
JSP's combined with the miss application of the MVC pattern have been holding back J2EE web development for many years. 
It's a big statement I know, please let me explain.
<p/>
MVC is a desktop GUI design pattern, which supports a separation of  roles in UI design. Model is the data, the 
View does the rendering and the Control is for modifying the data.  Now MVC is a fairly sophisticated UI pattern 
which solves the problem of multiple views and controls sharing the same data.  
<p/>
For most UI development however MVC is overkill. The control and the view are usually the same thing.  For example, 
a Select box is the view and the control and also holds the model. In Swing fortunately, most of the MVC design is 
hidden away below the surface.  In VB and Delphi there is no MVC at all.
<p/>
In the early days of J2EE web development design patterns were converted, and MVC was grabbed and early Servlet/JSP 
designs were branded as MVC. In their analysis the model was usually a DAO, the view was the JSP and control was a 
Servlet.  
<p/>
The effect of this was to lock in the design concept where the UI MVC roles were strictly separated. This fits well 
with the generalized architectural principle separating layers, and with the fact that JSPs are only really suitable 
for rendering output.
<p/>
Unfortunately the cost of this strict separation was the encapsulation. Most UI components encapsulate the view and 
the control. Click components (Controls) are responsible for both rendering themselves (view) and then understanding 
what they mean (control).
<p/>
To see this concept in action take a simple Click page where we have an ActionLink Control.
<pre class="codeJava">
<span class="kw">public class</span> ExamplePage <span class="kw">extends</span> Page {

    <span class="kw">public void</span> onInit() {
        ActionLink clickLink = new ActionLink("<span class="st">clickLink</span>");
        clickLink.setListener(this, "<span class="st">onClick</span>");
        addControl(clickLink);    
    }
    
    <span class="kw">public boolean</span> onClick() {
        System.out.println("<span class="st">onClick invoked</span>");
        <span class="kw">return true</span>;
    }
} 
</pre>
The ActionLink control renders the links <tt>href</tt> attribute in the HTML page.
<pre class="codeHtml">
&lt;a href="<span class="st">$clickLink.href</span>"&gt;Click Me&lt;/a&gt;
</pre>
If the user clicks the link the ActionLink control then invokes the invokes the Page's <code>onClick()</code> method. 
<p/>
Conversely with the JSP MVC architecture a JSP can tell you something, but it can't understand what it has just 
said. 
<p/>
With Click a control renders itself and processes the users input.  In OO terms this is called 
<i>encapsulation</i>.
<p/>

<h2>Velocity</h2>

TODO:
For rendering HTML Click uses the Velocity templating engine.
Instead of using JSPs Click uses the Velocity templating engine. If you have every had the pleasure of using 
Velocity you will find going back to JSP quite painful. Velocity provides a simple language which is intuative:

<pre class="codeHtml">
<span class="">#if</span>( <span class="">$customerList.size</span> > 0 )
  &lt;table&gt;
  <span class="">#foreach</span>( <span class="">$customer</span> <span class="">in</span> <span class="">$customerList</span> )
    &lt;tr&gt;
      &lt;td&gt;Name: &lt;/td&gt; &lt;td&gt;<span class="">$customer.name</span>&lt;/td&gt; 
      &lt;td&gt;Email:&lt;/td&gt; &lt;td&gt;<span class="">$customer.email</span>&lt;/td&gt;   
    &lt;/tr&gt;
  <span class="">#end</span>
  &lt;/table&gt;
<span class="">#else</span>
  No customers found.
<span class="">#end</span> 
</pre>

Compare this to the equivalent JSP Struts taglib code, and you should find Velocity eaiser to read.

<pre class="codeHtml">
&lt;logic:notEmpty name="<span class="">customerList</span>"&gt;
  &lt;table&gt;  
  &lt;logic:iterate id="<span class="">customer</span>" name="<span class="">customerList</span>"&gt;
    &lt;tr&gt;
      &lt;td&gt;Name: &lt;/td&gt; &lt;td&gt;&lt;bean:write name="<span class="">customer</span>" property="<span class="">name</span>"/&gt;&lt;/td&gt; 
      &lt;td&gt;Email:&lt;/td&gt; &lt;td&gt;&lt;bean:write name="<span class="">customer</span>" property="<span class="">email</span>"/&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/logic:iterate&gt; 
  &lt;/table&gt;
&lt;/logic:notEmpty&gt;
&lt;logic:empty name="<span class="">customerList</span>"&gt; 
  No customers found.
&lt;/logic:empty&gt;
</pre>

</table>
</body>
</html>

