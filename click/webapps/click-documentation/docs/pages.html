<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
 "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
 <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
 <meta name="Author" content="Malcolm Edgar"/>
 <link rel="stylesheet" type="text/css" href="../help.css"/>
</head>
<body> 
   
<h1>Pages</h1>
Pages are the heart of web applications. In Click, Pages encapsulate the processing of 
HTML requests and the rendering of HTML responses. The section discusses Click pages 
and covers to following topics:
<ul>
  <li><a href="#page-class">Classes</a> - page Java classes<p/>
  </li>
  <li><a href="#page-execution">Execution</a> - page execution sequence<p/>
  </li>
  <li><a href="#page-navigation">Navigation</a> - navigation between pages<p/>
  </li>
  <li><a href="#page-security">Security</a> - page security model<p/>
  </li>
  <li><a href="#page-error-handling">Error Handling</a> - page error handling model<p/>
  </li>
  <li><a href="#page-not-found">Page Not Found</a> - page not found handling<p/>
  </li>
</ul>

<p>&nbsp;</p>

In Click, a logical page is composed of a Java class and a Velocity template, with these
components being defined in page elements of the 
<a target="topic" href="configuration.html#application-configuration">click.xml</a> file.

<div class="code">
&lt;page path="<font color="red">search.htm</font>" classname="<font color="blue">com.mycorp.page.Search</font>"/&gt;
</div>

The path attribute specifies the location of the page Velocity template, and the classname
attribute specifies the page Java class name.

<a name="page-class"><h2>Classes</h2></a>

All custom Click pages must subclass the
<a target="topic" href="click-api/net/sf/click/Page.html">Page</a> base class.
The Page class and its associated companion classes, Context and Control, are depicted 
below in Figure 1.

<p/>
<img src="../images/click-class-diagram.png"/>
<h4>Figure 1. &nbsp; Page Class Diagram</h4>

The Page class provides a model attribute which is used to hold all the objects that
are rendered in the page's Velocity template. The model may also contain
<a target="topic" href="click-api/net/sf/click/Control.html">Control</a> objects, which
provide user interface controls on the Page.
<p/>
Pages also have an associated  
<a target="topic" href="click-api/net/sf/click/Context.html">Context</a> object
which references all the javax.servlet objects associated with the request. When 
programming in Click you use the Context object to access HttpServletRequest attributes, 
parameters and the HttpSession object.
<p/>
The Page class provide a number of empty handler methods which subclasses can override to
provide functionality:
<ul>
  <li>onInit()</li>
  <li>onSecurityCheck()</li>
  <li>onGet()</li>
  <li>onPost()</li>
  <li>onFinally()</li>
</ul>
The ClickServlet relies on instantiating Pages using a public no arguments constructor, 
so when you create Page subclasses you must ensure you don't add an incompatible
constructur. By convention in Click you place initialization code in an <tt>onInit()</tt>
method and you generally don't implement a constructor.

<a name="page-execution"><h2>Execution</h2></a>

The GET request execution sequence for Pages is summarised below in the Figure 2.

<p/>
<img src="../images/get-sequence-diagram.png"/>
<h4>Figure 2. &nbsp; GET Request Sequence Diagram</h4>


Stepping through this GET request sequence, a new Page instance is created and the 
attributes for the Page are set (context, format, headers, path). Next the <tt>onInit()</tt>
method is invoked. This is where you typically place your initialization code.
<p/>
The next method invoked is the <tt>onSecurityCheck()</tt> handler. This method can used to 
ensure the user is authorized to access the page, and if necessary can abort any 
further processing.
<p/>
The next step is the processing of the Page's controls. The ClickSerlvet gets the list of 
Controls from the page and then iterates through the list calling <tt>onProcess()</tt>. 
If any of the Control's <tt>onProcess()</tt> methods return false, processing of 
subsequent controls and the Page's <tt>onGet()</tt> method is aborted.
<p/>
If everything is executing normally the Page's <tt>onGet()</tt> method is now called.
<p/>
The next step is rendering the page template to generate the displayed HTML. The
ClickServlet gets the model from the Page as well as the path to its template. It then
merges the template with the page model and writes out results to the HttpServletResponse.
When the model is being merged with the template, any Controls in the model may be
rendered using their <tt>toString()</tt> method.
<p/>
The final step in this sequence is invoking the Page's <tt>onFinally()</tt> method. This 
method can be used to clean up resource associated with the Page before it is garbage
collected. The <tt>onFinally()</tt> method is garanteed to be called even if an exception
occurs in the previous steps.
<p/>
The execution sequence for POST requests is almost identical, except the <tt>onPost()</tt>
method is invoked instead on <tt>onGet()</tt>. See the 
<a href="../images/post-sequence-diagram.png">POST Request Sequence Diagram</a>.
<p/>
Another view on the execution flow of Pages is illustrated in the Activity diagram below.
<p/>
<img src="../images/activity-diagram.png"/>
<h4>Figure 3. &nbsp; Page Execution Activity Diagram</h4>


<a name="page-navigation"><h2>Navigation</h2></a>

Navigation between pages is achieved by using forwards, redirects and by setting the 
page template path.

<a name="page-foward"><h3>Forward</h3></a>

To forward to another page using the servlet 
<a target="topic" href="servlet-api/javax/servlet/RequestDispatcher.html">RequestDispatcher</a>
set the Page's forward property. For example to forward to a page with a path 
<tt>"<font color="blue">index.htm</font>"</tt>:
<div class="code">
public void onPost() {
   // Process form post
   ..
   
   setForward("<font color="blue">index.htm</font>");
}
</div>

This will invoke a new Page class instance mapped to the path 
<tt>"<font color="blue">index.htm</font>"</tt>. Note when a request is forwarded to another Page, 
the controls on the second page will not be processed. This prevents confusion and bugs,
like a form on the second page trying to process a POST request from the first page.

<h4>Forward Parameter Passing</h4>

When you forward to another page the request parameters are maintained. This is a handy way
of passing through state information through with the request. For example to you could
add a customer object as request parameter which is displayed in the template of the 
forwarded page.
<div class="code">
public boolean onViewClick() {
   Long id = viewLink.getValueLong();
   Customer customer = CustomerDatabase.getCustomer(id); 
    
   getContext().setRequestAttribute("<font color="red">customer</font>", customer);
   setForward("<font color="blue">view-customer.htm</font>");
   
   return false;
}
</div>

Forwarded to page template <tt>"<font color="blue">view-customer.htm</font>"</tt>:

<blockquote>
<pre>
&lt;html&gt;
 &lt;head&gt;
   &lt;title&gt;Customer Details&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
   &lt;h1&gt;Customer Details&lt;/h1&gt;
   &lt;pre&gt;
     Full Name: $<font color="red">customer</font>.fullName
     Email:     $<font color="red">customer</font>.email
     Telephone: $<font color="red">customer</font>.telephone
    &lt;/pre&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</blockquote>

Request attributes are automatically added to the Velocity Context object so are  
available in the page template.

<a name="page-template-path"><h3>Template Path</h3></a>

An alternative to forwarding to a new page is to simply set the path to the new
page template to render. With this approach the page template  being rendered must have 
everything it needs without having its associated Page object being created. Our modified 
example would be:
<div class="code">
public boolean onViewClick() {
   Long id = viewLink.getValueLong();
   Customer customer = CustomerDatabase.getCustomer(id); 
    
   <b>addModel</b>("<font color="red">customer</font>", customer);
   <b>setPath</b>("<font color="blue">view-customer.htm</font>");
   
   return false;
}
</div>
Note how the <font color="red">customer</font> object is passed through to the template in the Page model. This
approach of using the Page model is not available when you forward to another Page, as
the first Page object is "finalized" before the second Page object is created and any
model values would be lost.

<a name="page-redirect"><h3>Redirect</h3></a>

Redirects are another very useful way to navigate between pages. See 
HttpServletResponse.<a target="topic" href="servlet-api/javax/servlet/http/HttpServletResponse.html#sendRedirect(java.lang.String)">sendRedirect</a>(location)
for details.
<p/>
The great thing about redirects are that they provide a clean URL in the users browser 
which matches the page that they are viewing. This is important for when users want to
bookmark a page. The downside of redirects are that they involve a communications round 
trip with the users browser which requests the new page. Not only does this take time, 
it also means that all the page and request information is lost. 
<p/>
An example of a redirect to a <tt>"<font color="blue">logout.htm</font>"</tt>
page is provided below:
<div class="code">
public boolean onLogoutClick() {
   setRedirect("<font color="blue">logout.htm</font>");
   return false;
}
</div>

<h4>Redirect Parameter Passing</h4>

You can pass information between redirected pages using URL request parameters. 
The ClickServlet will encode the URL for you using
HttpServletResponse.<a target="topic" href="servlet-api/javax/servlet/http/HttpServletResponse.html#encodeRedirectURL(java.lang.String)">encodeRedirectURL</a>(url)
method. 
<p/>
In the example below a user will click on an OK button to confirm a payment. The 
<tt>onOkClick()</tt> button handler processes the payment, gets the payment transaction id, and then 
redirects to the <tt>"<font color="blue">trans-complete.htm</font>"</tt> page with the
transaction id encoded in the URL.
<div class="code">
public class Payment extends Page {
   ..
   
   public boolean onOkClick() {
      if (form.isValid()) {
         // Process payment
         ..
         
         // Get transaction id
         Long id = ..
   
         setRedirect("<font color="blue">trans-complete.htm</font>?<font color="red">trans-id</font>=" + id);
      
         return false; 
      } 
  
      return true;
   }
   
   ..
}
</div>

The Page class for the <tt>"<font color="blue">trans-complete.htm</font>"</tt> page can 
then get the transaction id through the request parameter 
<tt>"<font color="red">trans-id</font>"</tt>:
<div class="code">
public class TransComplete extends Page {
   ..
   
   public void onInit() {
      String id = getContext().getRequest().getParameter("<font color="red">trans-id</font>");
   
      if (id != null) {
         // Get transaction details
         ..
      }
   }
   
   ..
}
</div>

<h4>Post Redirect</h4>
The parameter passing example above is also an example of a Post Redirect. The Post
Redirect technique is a very useful method of preventing users from submitting a form 
twice by hitting the refresh button.


<a name="page-security"><h2>Security</h2></a>

Pages provide an 
<a target="topic" href="click-api/net/sf/click/Page.html#onSecurityCheck()">onSecurityCheck</a> 
event handler which application pages override to implement authentication or
authorization capabilities.

<h4>Application Authentication</h4>
Applications can use this method to implement their own security model. The example 
class below provides a base Secure page class which other pages can extend
to ensure the user is logged in. In this example the login page adds a "user" object to
the session when a user successfully authenticates. This Secure page then checks to make sure
this session attribute is present, otherwise the request is redirected back to the login
page.
<div class="code">
public class Secure extends Page {

    public boolean onSecurityCheck() {
    
        if (getContext().getSessionAttribute("user") != null) {
            return true;
            
        } else {
            setRedirect("login.htm");
            return false;
        }
    }
}
</div>

<h4>Container Authentication</h4>
Alternatively you can also use the security services provided by the J2EE Servlet 
Container. For instance to ensure users have been authenticated by the Serlvet Container
you could use a Secure page of:
<div class="code">
public class Secure extends Page {

    public boolean onSecurityCheck() {
    
        if (getContext().getRequest().<a target="topic" href="servlet-api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()">getRemoteUser</a>() != null) {
            return true;
            
        } else {
            setRedirect("login.htm");
            return false;
        }
    }
}
</div>

<h4>Container Access Control</h4>
The Servlet Container also provides facilities to enforce role based access control 
(authorization). The example below is a base page to ensure only users
in the "admin" role can access the page, otherwise users are redirected to the login page.
Application Admin pages would extend this secure page to provide their funcationality.
<div class="code">
public class AdminPage extends Page {

    public boolean onSecurityCheck() {
    
        if (getContext().getRequest().<a target="topic" href="servlet-api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)">isUserInRole</a>("admin")) {
            return true;

        } else {
            setRedirect("login.htm?");
            return false;
        }
    }
}
</div>

<h4>Logging Out</h4>
To logout using the application or container based security models you would simply 
invalidate the session.
<div class="code">
public class Logout extends Page {

    public boolean onInit() {
        getContext().getSession().<a target="topic" href="servlet-api/javax/servlet/http/HttpSession.html#invalidate()">invalidate</a>();
    }
}
</div>

For more information of the J2EE Servlet security facilities see the Servlet
<a target="topic" href="http://java.sun.com/products/servlet/reference/api/index.html">Specification</a>.

<a name="page-error-handling"><h2>Error Handling</h2></a>

If an Exception occurs processing a Page object or rendering a page template the error
is delegated to the registered error.htm

TODO:

<a name="page-not-found"><h2>Page Not Found</h2></a>

If the ClickServlet cannot find a requested page in the <tt>click.xml</tt> config file
it will use the registered "not-found.htm" page. The Click not found page is automatically configured as:
<div class="code">
&lt;page path="<font color="red">click/not-found.htm</font>" classname="<font color="blue">net.sf.click.Page</font>"/&gt;
</div>

You can override the default configuration and specify your own class, but you cannot change the path.
<p/>
When the ClickSevlet starts up it checks to see whether the <tt>not-found.htm</tt> template exists in the 
<tt>click</tt> web sub directory. If it cannot find the page the ClickServlet will automatically deploy one.
<p/>
You can tailor the "<tt>click/not-found.htm</tt>" template to suite you own needs. This page template
has access to the usual Click parameters:
<ul>
  <li>$context</li>
  <li>$format</li>
  <li>$request</li>
  <li>$response</li>
  <li>$session</li>
</ul>

</body>
</html>