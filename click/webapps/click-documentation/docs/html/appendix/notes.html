<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Performance, Implementation, and Design Notes</title>
<link rel="previous" href="changes.html">
<link rel="next" href="../references.html">
<link rel="contents" href="../cover.html#toc">
<link rel="stylesheet" type="text/css" href= 
"http://www.w3.org/StyleSheets/TR/W3C-REC">
<link rel="STYLESHEET" href="../style/default.css" type="text/css">
</head>
<body>
<div class="navbar" align="center">&nbsp;<a href="changes.html">previous</a>
&nbsp; <a href="../references.html">next</a> &nbsp; <a href= 
"../cover.html#minitoc">contents</a> &nbsp; <a href="../index/elements.html">
elements</a> &nbsp; <a href="../index/attributes.html">attributes</a> &nbsp; <a
href="../index/list.html">index</a> 

<hr></div>

<h1 align="center"><a name="h-B">Appendix B:</a> Performance, Implementation,
and Design Notes</h1>

<div class="subtoc">
<p><strong>Contents</strong></p>

<ol>
<li><a class="tocxref" href="#h-B.1">Notes on invalid documents</a></li>

<li><a class="tocxref" href="#h-B.2">Special characters in URI attribute
values</a> 

<ol>
<li><a class="tocxref" href="#h-B.2.1">Non-ASCII characters in URI attribute
values</a></li>

<li><a class="tocxref" href="#h-B.2.2">Ampersands in URI attribute
values</a></li>
</ol>
</li>

<li><a class="tocxref" href="#h-B.3">SGML implementation notes</a> 

<ol>
<li><a class="tocxref" href="#h-B.3.1">Line breaks</a></li>

<li><a class="tocxref" href="#h-B.3.2">Specifying non-HTML data</a> 

<ul>
<li><a class="tocxref" href="#h-B.3.2.1">Element content</a></li>

<li><a class="tocxref" href="#h-B.3.2.2">Attribute values</a></li>
</ul>
</li>

<li><a class="tocxref" href="#h-B.3.3">SGML features with limited
support</a></li>

<li><a class="tocxref" href="#h-B.3.4">Boolean attributes</a></li>

<li><a class="tocxref" href="#h-B.3.5">Marked Sections</a></li>

<li><a class="tocxref" href="#h-B.3.6">Processing Instructions</a></li>

<li><a class="tocxref" href="#h-B.3.7">Shorthand markup</a></li>
</ol>
</li>

<li><a class="tocxref" href="#h-B.4">Notes on helping search engines index your
Web site</a> 

<ol>
<li><a class="tocxref" href="#h-B.4.1">Search robots</a> 

<ul>
<li><a class="tocxref" href="#h-B.4.1.1">The robots.txt file</a></li>

<li><a class="tocxref" href="#h-B.4.1.2">Robots and the META element</a></li>
</ul>
</li>
</ol>
</li>

<li><a class="tocxref" href="#h-B.5">Notes on tables</a> 

<ol>
<li><a class="tocxref" href="#h-B.5.1">Design rationale</a> 

<ul>
<li><a class="tocxref" href="#h-B.5.1.1">Dynamic reformatting</a></li>

<li><a class="tocxref" href="#h-B.5.1.2">Incremental display</a></li>

<li><a class="tocxref" href="#h-B.5.1.3">Structure and presentation</a></li>

<li><a class="tocxref" href="#h-B.5.1.4">Row and column groups</a></li>

<li><a class="tocxref" href="#h-B.5.1.5">Accessibility</a></li>
</ul>
</li>

<li><a class="tocxref" href="#h-B.5.2">Recommended Layout Algorithms</a> 

<ul>
<li><a class="tocxref" href="#h-B.5.2.1">Fixed Layout Algorithm</a></li>

<li><a class="tocxref" href="#h-B.5.2.2">Autolayout Algorithm</a></li>
</ul>
</li>
</ol>
</li>

<li><a class="tocxref" href="#h-B.6">Notes on forms</a> 

<ol>
<li><a class="tocxref" href="#h-B.6.1">Incremental display</a></li>

<li><a class="tocxref" href="#h-B.6.2">Future projects</a></li>
</ol>
</li>

<li><a class="tocxref" href="#h-B.7">Notes on scripting</a> 

<ol>
<li><a class="tocxref" href="#h-B.7.1">Reserved syntax for future script
macros</a> 

<ul>
<li><a class="tocxref" href="#h-B.7.1.1">Current Practice for Script
Macros</a></li>
</ul>
</li>
</ol>
</li>

<li><a class="tocxref" href="#h-B.8">Notes on frames</a></li>

<li><a class="tocxref" href="#h-B.9">Notes on accessibility</a></li>

<li><a class="tocxref" href="#h-B.10">Notes on security</a> 

<ol>
<li><a class="tocxref" href="#h-B.10.1">Security issues for forms</a></li>
</ol>
</li>
</ol>
</div>

<p>The following notes are informative, not normative. Despite the appearance
of words such as "must" and "should", all requirements in this section appear
elsewhere in the specification.</p>

<h2><a name="h-B.1">B.1</a> <a name="notes-invalid-docs">Notes on invalid
documents</a></h2>

<p>This specification does not define how conforming user agents handle general
<span class="index-def" title="error::handling by user agents|user agent::and 
error conditions"><a name="didx-error">error conditions,</a></span> including
how user agents behave when they encounter elements, attributes, attribute
values, or entities not specified in this document.</p>

<p>However, to facilitate experimentation and interoperability between
implementations of various versions of HTML, we recommend the following
behavior:</p>

<ul>
<li>If a user agent encounters an element it does not recognize, it should try
to render the element's content.</li>

<li>If a user agent encounters an attribute it does not recognize, it should
ignore the entire attribute specification (i.e., the attribute and its
value).</li>

<li>If a user agent encounters an attribute value it doesn't recognize, it
should use the default attribute value.</li>

<li>If it encounters an undeclared entity, the entity should be treated as
character data.</li>
</ul>

<p>We also recommend that user agents provide support for notifying the user of
such errors.</p>

<p>Since user agents may vary in how they handle error conditions, authors and
users must not rely on specific error recovery behavior.</p>

<p>The HTML 2.0 specification (<a rel="biblioentry" href= 
"../references.html#ref-RFC1866" class="informref">[RFC1866]</a>) observes that
many HTML 2.0 user agents assume that a document that does not begin with a
document type declaration refers to the HTML 2.0 specification. As experience
shows that this is a poor assumption, the current specification does not
recommend this behavior.</p>

<p>For reasons of interoperability, authors must not "extend" HTML through the
available SGML mechanisms (e.g., extending the DTD, adding a new set of entity
definitions, etc.).</p>

<h2><a name="h-B.2">B.2</a> Special characters in URI attribute values</h2>

<h3><a name="h-B.2.1">B.2.1</a> <span class="index-inst" title="URI::non-ASCII 
characters in attribute values"><a name="non-ascii-chars">Non-ASCII characters
in URI attribute values</a></span></h3>

<p>Although URIs do not contain non-ASCII values (see <a rel="biblioentry"
href="../references.html#ref-URI" class="normref">[URI]</a>, section 2.1)
authors sometimes specify them in attribute values expecting URIs (i.e.,
defined with <a href="../sgml/dtd.html#URI">%URI;</a> in the <a href= 
"../sgml/dtd.html">DTD</a>). For instance, the following <a href= 
"../struct/links.html#adef-href" class="noxref"><samp class="ainst">
href</samp></a> value is <strong>illegal</strong>:</p>

<pre>
&lt;A href="http://foo.org/H&aring;kon"&gt;...&lt;/A&gt;
</pre>

<p>We recommend that user agents adopt the following convention for handling
non-ASCII characters in such cases:</p>

<ol>
<li>Represent each character in UTF-8 (see <a rel="biblioentry" href= 
"../references.html#ref-RFC2279" class="normref">[RFC2279]</a>) as one or more
bytes.</li>

<li>Escape these bytes with the URI escaping mechanism (i.e., by converting
each byte to %HH, where HH is the hexadecimal notation of the byte value).</li>
</ol>

<p>This procedure results in a syntactically legal URI (as defined in <a rel= 
"biblioentry" href="../references.html#ref-RFC1738" class="normref">
[RFC1738]</a>, section 2.2 or <a rel="biblioentry" href= 
"../references.html#ref-RFC2141" class="normref">[RFC2141]</a>, section 2) that
is independent of the <a href="../charset.html#doc-char-set">character
encoding</a> to which the HTML document carrying the URI may have been
transcoded.</p>

<div class="note">
<p><em><strong>Note.</strong> Some older user agents trivially process URIs in
HTML using the bytes of the <a href="../charset.html#doc-char-set">character
encoding</a> in which the document was received. Some older HTML documents rely
on this practice and break when transcoded. User agents that want to handle
these older documents should, on receiving a URI containing characters outside
the legal set, first use the conversion based on UTF-8. Only if the resulting
URI does not resolve should they try constructing a URI based on the bytes of
the <a href="../charset.html#doc-char-set">character encoding</a> in which the
document was received.</em></p>
</div>

<div class="note">
<p><em><span class="index-inst" title="anchor::non-ASCII characters in name"><a
name="idx-anchor"><strong>Note.</strong></a></span> The same conversion based
on UTF-8 should be applied to values of the <a href= 
"../struct/links.html#adef-name-A" class="noxref"><samp class="ainst-A">
name</samp></a> attribute for the <a href="../struct/links.html#edef-A" class= 
"noxref"><samp class="einst">A</samp></a> element.</em></p>
</div>

<h3><a name="h-B.2.2">B.2.2</a> <a name="ampersands-in-uris">Ampersands in URI
attribute values</a></h3>

<p>The URI that is constructed when a <a href= 
"../interact/forms.html#submit-format">form is submitted</a> may be used as an
anchor-style link (e.g., the <a href="../struct/links.html#adef-href" class= 
"noxref"><samp class="ainst">href</samp></a> attribute for the <a href= 
"../struct/links.html#edef-A" class="noxref"><samp class="einst">A</samp></a>
element). Unfortunately, the use of the "&amp;" character to separate form
fields interacts with its use in SGML attribute values to delimit <a href= 
"../intro/sgmltut.html#character-entities">character entity references</a>. For
example, to use the URI "http://host/?x=1&amp;y=2" as a linking URI, it must be
written &lt;A href="http://host/?x=1&amp;#38;y=2"&gt; or &lt;A
href="http://host/?x=1&amp;amp;y=2"&gt;.</p>

<p>We recommend that HTTP server implementors, and in particular, CGI
implementors support the use of ";" in place of "&amp;" to save authors the
trouble of escaping "&amp;" characters in this manner.</p>

<h2><a name="h-B.3">B.3</a> <span class="index-inst" title= 
"SGML::implementation notes"><a name="sgml">SGML implementation
notes</a></span></h2>

<h3><a name="h-B.3.1">B.3.1</a> <span class="index-inst" title="SGML::treatment 
of line breaks"><a name="notes-line-breaks">Line breaks</a></span></h3>

<p>SGML (see <a rel="biblioentry" href="../references.html#ref-ISO8879" class= 
"normref">[ISO8879]</a>, section 7.6.1) specifies that a line break immediately
following a start tag must be ignored, as must a line break immediately before
an end tag. This applies to all HTML elements without exception.</p>

<p>The following two HTML examples must be rendered identically:</p>

<div class="example">
<pre>
&lt;P&gt;Thomas is watching TV.&lt;/P&gt;
</pre>

<pre>
&lt;P&gt;
Thomas is watching TV.
&lt;/P&gt;
</pre>
</div>

<p>So must the following two examples:</p>

<div class="example">
<pre>
&lt;A&gt;My favorite Website&lt;/A&gt;
</pre>

<pre>
&lt;A&gt;
My favorite Website
&lt;/A&gt;
</pre>
</div>

<h3><a name="h-B.3.2">B.3.2</a> <span class="index-inst" title= 
"HTML::specifying data external to"><a name="notes-specifying-data">Specifying
non-HTML data</a></span></h3>

<p><a href="../interact/scripts.html">Script</a> and <a href= 
"../present/styles.html">style</a> data may appear as element content or
attribute values. The following sections describe the boundary between HTML
markup and foreign data.</p>

<div class="note">
<p><em><strong>Note.</strong> The <a href="../sgml/dtd.html">DTD</a> defines
script and style data to be CDATA for both element content and attribute
values. SGML rules do not allow <a href="../charset.html#entities">character
references</a> in CDATA element content but do allow them in CDATA attribute
values. Authors should pay particular attention when cutting and pasting script
and style data between element content and attribute values.</em></p>

<p><em>This asymmetry also means that when transcoding from a richer to a
poorer character encoding, the transcoder cannot simply replace unconvertible
characters in script or style data with the corresponding numeric character
references; it must parse the HTML document and know about each script and
style language's syntax in order to process the data correctly.</em></p>
</div>

<h4>Element content<a name="h-B.3.2.1">&nbsp;</a></h4>

<p>When script or style data is the content of an element (<a href= 
"../interact/scripts.html#edef-SCRIPT" class="noxref"><samp class=
"einst">SCRIPT</samp></a> and <a href="../present/styles.html#edef-STYLE"
class="noxref"><samp class="einst">STYLE</samp></a>), the data begins
immediately after the element start tag and ends at the first ETAGO ("&lt;/")
delimiter followed by a name start character ([a-zA-Z]); note that this may not
be the element's end tag. Authors should therefore escape "&lt;/" within the
content. Escape mechanisms are specific to each scripting or style sheet
language.</p>

<div class="illegal-example">
<p><span class="example-title">ILLEGAL EXAMPLE:</span>
<br>
 The following script data incorrectly contains a "&lt;/" sequence (as part of
"&lt;/EM&gt;") before the <a href="../interact/scripts.html#edef-SCRIPT" class= 
"noxref"><samp class="einst">SCRIPT</samp></a> end tag:</p>

<pre>
    &lt;SCRIPT type="text/javascript"&gt;
      document.write ("&lt;EM&gt;This won't work&lt;/EM&gt;")
    &lt;/SCRIPT&gt;
</pre>
</div>

<div class="example">
<p>In JavaScript, this code can be expressed legally by hiding the ETAGO
delimiter before an SGML name start character:</p>

<pre>
    &lt;SCRIPT type="text/javascript"&gt;
      document.write ("&lt;EM&gt;This will work&lt;\/EM&gt;")
    &lt;/SCRIPT&gt;
</pre>

<p>In Tcl, one may accomplish this as follows:</p>

<pre>
    &lt;SCRIPT type="text/tcl"&gt;
      document write "&lt;EM&gt;This will work&lt;\/EM&gt;"
    &lt;/SCRIPT&gt;
</pre>

<p>In VBScript, the problem may be avoided with the <tt>Chr()</tt>
function:</p>

<pre>
    "&lt;EM&gt;This will work&lt;" &amp; Chr(47) &amp; "EM&gt;"
</pre>
</div>

<h4>Attribute values<a name="h-B.3.2.2">&nbsp;</a></h4>

<p>When script or style data is the value of an attribute (either <a href= 
"../present/styles.html#adef-style" class="noxref"><samp class="ainst">
style</samp></a> or the <a href="../interact/scripts.html#events">intrinsic
event</a> attributes), authors should escape occurrences of the delimiting
single or double quotation mark within the value according to the script or
style language convention. Authors should also escape occurrences of "&amp;" if
the "&amp;" is not meant to be the beginning of a <a href= 
"../charset.html#entities">character reference</a>.</p>

<ul>
<li>'"' should be written as "&amp;quot;" or "&amp;#34;"</li>

<li>'&amp;' should be written as "&amp;amp;" or "&amp;#38;"</li>
</ul>

<div class="example">
<p>Thus, for example, one could write:</p>

<pre>
 &lt;INPUT name="num" value="0"
 onchange="if (compare(this.value, &amp;quot;help&amp;quot;)) {gethelp()}"&gt;
</pre>
</div>

<h3><a name="h-B.3.3">B.3.3</a> <span class="index-inst" title="SGML::features 
with limited support"><a name="sgmlfeatures">SGML features with limited
support</a></span></h3>

<p>SGML systems conforming to <a rel="biblioentry" href= 
"../references.html#ref-ISO8879" class="normref">[ISO8879]</a> are expected to
recognize a <span class="index-inst" title="SGML::features with limited
support"><a name="idx-SGML-3">number of features</a></span> that aren't widely
supported by HTML user agents. We recommend that authors avoid using all of
these features.</p>

<h3><a name="h-B.3.4">B.3.4</a> <span class="index-inst" title="boolean 
attribute|notes about minimized"><a name="sgml-boolean">Boolean
attributes</a></span></h3>

<p>Authors should be aware that many user agents only recognize the minimized
form of boolean attributes and not the full form.</p>

<div class="example">
<p>For instance, authors may want to specify:</p>

<pre>
&lt;OPTION selected&gt;
</pre>

<p><em>instead of</em></p>

<pre>
&lt;OPTION selected="selected"&gt;
</pre>
</div>

<h3><a name="h-B.3.5">B.3.5</a> Marked Sections</h3>

<p>Marked sections play a role similar to the #ifdef construct recognized by C
preprocessors.</p>

<div class="example">
<pre>
&lt;![INCLUDE[
 &lt;!-- this will be included --&gt;
]]&gt;

&lt;![IGNORE[
 &lt;!-- this will be ignored --&gt;
]]&gt;
</pre>
</div>

<p>SGML also defines the use of marked sections for CDATA content, within which
"&lt;" is not treated as the start of a tag, e.g.,</p>

<div class="example">
<pre>
&lt;![CDATA[
 &lt;an&gt; example of &lt;sgml&gt; markup that is
 not &lt;painful&gt; to write with &lt; and such.
]]&gt;
</pre>
</div>

<p>The telltale sign that a user agent doesn't recognize a marked section is
the appearance of "]]&gt;", which is seen when the user agent mistakenly uses
the first "&gt;" character as the end of the tag starting with "&lt;![".</p>

<h3><a name="h-B.3.6">B.3.6</a> Processing Instructions</h3>

<p>Processing instructions are a mechanism to capture platform-specific idioms.
A processing instruction begins with &lt;? and ends with &gt;</p>

<pre>
&lt;?<em>instruction</em> &gt;
</pre>

<div class="example">
<p>For example:</p>

<pre>
&lt;?&gt;
&lt;?style tt = font courier&gt;
&lt;?page break&gt;
&lt;?experiment&gt; ... &lt;?/experiment&gt;
</pre>
</div>

<p>Authors should be aware that many user agents render processing instructions
as part of the document's text.</p>

<h3><a name="h-B.3.7">B.3.7</a> Shorthand markup</h3>

<p>Some SGML SHORTTAG constructs save typing but add no expressive capability
to the SGML application. Although these constructs technically introduce no
ambiguity, they reduce the robustness of documents, especially when the
language is enhanced to include new elements. Thus, while SHORTTAG constructs
of SGML related to attributes are widely used and implemented, those related to
elements are not. Documents that use them are conforming SGML documents, but
are unlikely to work with many existing HTML tools.</p>

<p>The SHORTTAG constructs in question are the following:</p>

<div class="example">
<ul>
<li>NET tags: 

<pre>
&lt;name/.../
</pre>
</li>

<li>closed Start Tag: 

<pre>
&lt;name1&lt;name2&gt;
</pre>
</li>

<li>Empty Start Tag: 

<pre>
&lt;&gt;
</pre>
</li>

<li>Empty End Tag: 

<pre>
&lt;/&gt;
</pre>
</li>
</ul>
</div>

<h2><a name="h-B.4">B.4</a> <span class="index-inst" title="search 
engine::helping"><a name="recs">Notes on helping search engines index your Web
site</a></span></h2>

<p>This section provides some simple suggestions that will make your documents
more accessible to search engines.</p>

<dl>
<dt><strong>Define the document language</strong></dt>

<dd>In the global context of the Web it is important to know which human
language a page was written in. This is discussed in the section on <a href= 
"../struct/dirlang.html#language-info">language information</a>.</dd>

<dt><strong>Specify language variants of this document</strong></dt>

<dd>If you have prepared translations of this document into other languages,
you should use the <a href="../struct/links.html#edef-LINK" class="noxref">
<samp class="einst">LINK</samp></a> element to reference these. This allows an
indexing engine to offer users search results in the user's preferred language,
regardless of how the query was written. For instance, the following links
offer French and German alternatives to a search engine: 

<pre class="example">
&lt;LINK rel="alternate" 
         type="text/html"
         href="mydoc-fr.html" hreflang="fr"
         lang="fr" title="La vie souterraine"&gt;
&lt;LINK rel="alternate" 
         type="text/html"
         href="mydoc-de.html" hreflang="de"
         lang="de" title="Das Leben im Untergrund"&gt;
</pre>
</dd>

<dt><strong>Provide keywords and descriptions</strong></dt>

<dd>Some indexing engines look for <a href="../struct/global.html#edef-META"
class="noxref"><samp class="einst">META</samp></a> elements that define a
comma-separated list of keywords/phrases, or that give a short description.
Search engines may present these keywords as the result of a search. The value
of the <a href="../struct/global.html#adef-name-META" class="noxref"><samp
class="ainst-META">name</samp></a> attribute sought by a search engine is not
defined by this specification. Consider these examples, 

<pre class="example">
&lt;META name="keywords" content="vacation,Greece,sunshine"&gt;
&lt;META name="description" content="Idyllic European vacations"&gt;
</pre>
</dd>

<dt><strong>Indicate the beginning of a collection</strong></dt>

<dd>Collections of word processing documents or presentations are frequently
translated into collections of HTML documents. It is helpful for search results
to reference the beginning of the collection in addition to the page hit by the
search. You may help search engines by using the <a href= 
"../struct/links.html#edef-LINK" class="noxref"><samp class="einst">
LINK</samp></a> element with <b>rel="start"</b> along with the <a href= 
"../struct/global.html#adef-title" class="noxref"><samp class="ainst">
title</samp></a> attribute, as in: 

<pre class="example">
 
&lt;LINK rel="start" 
         type="text/html"
         href="page1.html" 
         title="General Theory of Relativity"&gt;
</pre>
</dd>

<dt><strong>Provide robots with indexing instructions</strong></dt>

<dd>People may be surprised to find that their site has been indexed by an
indexing robot and that the robot should not have been permitted to visit a
sensitive part of the site. Many Web robots offer facilities for Web site
administrators and content providers to limit what the robot does. This is
achieved through two mechanisms: a "robots.txt" file and the <a href= 
"../struct/global.html#edef-META" class="noxref"><samp class="einst">
META</samp></a> element in HTML documents, described below.</dd>
</dl>

<h3><a name="h-B.4.1">B.4.1</a> <span class="index-inst" title="search 
robot::helping"><a name="idx-search_robot">Search robots</a></span></h3>

<h4>The robots.txt file<a name="h-B.4.1.1">&nbsp;</a></h4>

<p>When a Robot visits a Web site, say http://www.foobar.com/, it firsts checks
for http://www.foobar.com/robots.txt. If it can find this document, it will
analyze its contents to see if it is allowed to retrieve the document. You can
customize the robots.txt file to apply only to specific robots, and to disallow
access to specific directories or files.</p>

<p>Here is a sample robots.txt file that prevents all robots from visiting the
entire site</p>

<pre>
        User-agent: *    # applies to all robots
        Disallow: /      # disallow indexing of all pages
</pre>

<p>The Robot will simply look for a "/robots.txt" URI on your site, where a
site is defined as a HTTP server running on a particular host and port number.
Here are some sample locations for <tt>robots.txt</tt>:</p>

<div class="example">
<table summary="Locations for robots.txt file" align="center" border="0"
cellpadding="10" cellspacing="0">
<tr bgcolor="#F0E0E0">
<th>Site URI</th>
<th>URI for <tt>robots.txt</tt></th>
</tr>

<tr>
<td>http://www.w3.org/</td>
<td>http://www.w3.org/robots.txt</td>
</tr>

<tr>
<td>http://www.w3.org:80/</td>
<td>http://www.w3.org:80/robots.txt</td>
</tr>

<tr>
<td>http://www.w3.org:1234/</td>
<td>http://www.w3.org:1234/robots.txt</td>
</tr>

<tr>
<td>http://w3.org/</td>
<td>http://w3.org/robots.txt</td>
</tr>
</table>
</div>

<p>There can only be a single "/robots.txt" on a site. Specifically, you should
not put "robots.txt" files in user directories, because a robot will never look
at them. If you want your users to be able to create their own "robots.txt",
you will need to merge them all into a single "/robots.txt". If you don't want
to do this your users might want to use the Robots META Tag instead.</p>

<p>Some tips: URI's are case-sensitive, and "/robots.txt" string must be all
lower-case. Blank lines are not permitted within a single record in the
"robots.txt" file.</p>

<p>There must be exactly one "User-agent" field per record. The robot should be
liberal in interpreting this field. A case-insensitive substring match of the
name without version information is recommended.</p>

<p>If the value is "*", the record describes the default access policy for any
robot that has not matched any of the other records. It is not allowed to have
multiple such records in the "/robots.txt" file.</p>

<p>The "Disallow" field specifies a partial URI that is not to be visited. This
can be a full path, or a partial path; any URI that starts with this value will
not be retrieved. For example,</p>

<pre>
    <b>Disallow: /help</b> disallows both /help.html and /help/index.html, whereas
    <b>Disallow: /help/</b> would disallow /help/index.html but allow /help.html. 
</pre>

<p>An empty value for "Disallow", indicates that all URIs can be retrieved. At
least one "Disallow" field must be present in the robots.txt file.</p>

<h4>Robots and the META element<a name="h-B.4.1.2">&nbsp;</a></h4>

<p>The <a href="../struct/global.html#edef-META" class="noxref"><samp class= 
"einst">META</samp></a> element allows HTML authors to tell visiting robots
whether a document may be indexed, or used to harvest more links. No server
administrator action is required.</p>

<div class="example">
<p>In the following example a robot should neither index this document, nor
analyze it for links.</p>

<pre>
&lt;META name="ROBOTS" content="NOINDEX, NOFOLLOW"&gt;
</pre>

<p>The list of terms in the content is <tt>ALL</tt>, <tt>INDEX</tt>, <tt>
NOFOLLOW</tt>, <tt>NOINDEX</tt>.</p>
</div>

<div class="note">
<p><em><strong>Note.</strong> In early 1997 only a few robots implement this,
but this is expected to change as more public attention is given to controlling
indexing robots.</em></p>
</div>

<h2><a name="h-B.5">B.5</a> <a name="notes-tables">Notes on tables</a></h2>

<h3><a name="h-B.5.1">B.5.1</a> Design rationale</h3>

<p>The HTML table model has evolved from studies of existing SGML tables
models, the treatment of tables in common word processing packages, and a wide
range of tabular layout techniques in magazines, books and other paper-based
documents. The model was chosen to allow simple tables to be expressed simply
with extra complexity available when needed. This makes it practical to create
the markup for HTML tables with everyday text editors and reduces the learning
curve for getting started. This feature has been very important to the success
of HTML to date.</p>

<p>Increasingly, people are creating tables by converting from other document
formats or by creating them directly with WYSIWYG editors. It is important that
the HTML table model fit well with these authoring tools. This affects how the
cells that span multiple rows or columns are represented, and how alignment and
other presentation properties are associated with groups of cells.</p>

<h4>Dynamic reformatting<a name="h-B.5.1.1">&nbsp;</a></h4>

<p>A major consideration for the HTML table model is that the author does not
control how a user will size a table, what fonts he or she will use, etc. This
makes it risky to rely on column widths specified in terms of absolute pixel
units. Instead, tables must be able to change sizes dynamically to match the
current window size and fonts. Authors can provide guidance as to the relative
widths of columns, but user agents should ensure that columns are wide enough
to render the width of the largest element of the cell's content. If the
author's specification must be overridden, relative widths of individual
columns should not be changed drastically.</p>

<h4><span class="index-inst" title="table::incremental display notes"><a name= 
"idx-table">Incremental display</a></span><a name="h-B.5.1.2">&nbsp;</a></h4>

<p>For large tables or slow network connections, incremental table display is
important to user satisfaction. User agents should be able to begin displaying
a table before all of the data has been received. The default window width for
most user agents shows about 80 characters, and the graphics for many HTML
pages are designed with these defaults in mind. By specifying the number of
columns, and including provision for control of table width and the widths of
different columns, authors can give hints to user agents that allow the
incremental display of table contents.</p>

<p>For incremental display, the browser needs the number of columns and their
widths. The default width of the table is the current window size
(<tt>width="100%"</tt>). This can be altered by setting the <a href= 
"../struct/tables.html#adef-width-TABLE" class="noxref"><samp class=
"ainst-TABLE">width</samp></a> attribute of the <a href= 
"../struct/tables.html#edef-TABLE" class="noxref"><samp class="einst">
TABLE</samp></a> element. By default, all columns have the same width, but you
can specify column widths with one or more <a href= 
"../struct/tables.html#edef-COL" class="noxref"><samp class="einst">
COL</samp></a> elements before the table data starts.</p>

<p>The remaining issue is the number of columns. Some people have suggested
waiting until the first row of the table has been received, but this could take
a long time if the cells have a lot of content. On the whole it makes more
sense, when incremental display is desired, to get authors to explicitly
specify the number of columns in the <a href="../struct/tables.html#edef-TABLE"
class="noxref"><samp class="einst">TABLE</samp></a> element.</p>

<p>Authors still need a way of telling user agents whether to use incremental
display or to size the table automatically to fit the cell contents. In the two
pass auto-sizing mode, the number of columns is determined by the first pass.
In the incremental mode, the number of columns must be stated up front (with <a
href="../struct/tables.html#edef-COL" class="noxref"><samp class="einst">
COL</samp></a> or <a href="../struct/tables.html#edef-COLGROUP" class="noxref">
<samp class="einst">COLGROUP</samp></a> elements).</p>

<h4>Structure and presentation<a name="h-B.5.1.3">&nbsp;</a></h4>

<p>HTML distinguishes structural markup such as paragraphs and quotations from
rendering idioms such as margins, fonts, colors, etc. How does this distinction
affect tables? From the purist's point of view, the alignment of text within
table cells and the borders between cells is a rendering issue, not one of
structure. In practice, though, it is useful to group these with the structural
information, as these features are highly portable from one application to the
next. The HTML table model leaves most rendering information to associated
style sheets. The model presented in this specification is designed to take
advantage of such style sheets but not to require them.</p>

<p>Current desktop publishing packages provide very rich control over the
rendering of tables, and it would be impractical to reproduce this in HTML,
without making HTML into a bulky rich text format like RTF or MIF. This
specification does, however, offer authors the ability to choose from a set of
commonly used classes of border styles. The <a href= 
"../struct/tables.html#adef-frame" class="noxref"><samp class="ainst-TABLE">
frame</samp></a> attribute controls the appearance of the border frame around
the table while the <a href="../struct/tables.html#adef-rules" class="noxref">
<samp class="ainst-TABLE">rules</samp></a> attribute determines the choice of
rulings within the table. A finer level of control will be supported via
rendering annotations. The <a href="../present/styles.html#adef-style" class= 
"noxref"><samp class="ainst-TABLE">style</samp></a> attribute can be used for
specifying rendering information for individual elements. Further rendering
information can be given with the <a href="../present/styles.html#edef-STYLE"
class="noxref"><samp class="einst">STYLE</samp></a> element in the document
head or via linked style sheets.</p>

<p>During the development of this specification, a number of avenues were
investigated for specifying the ruling patterns for tables. One issue concerns
the kinds of statements that can be made. Including support for edge
subtraction as well as edge addition leads to relatively complex algorithms.
For instance, work on allowing the full set of table elements to include the <a
href="../struct/tables.html#adef-frame" class="noxref"><samp class=
"ainst-TABLE">frame</samp></a> and <a href="../struct/tables.html#adef-rules"
class="noxref"><samp class="ainst-TABLE">rules</samp></a> attributes led to an
algorithm involving some 24 steps to determine whether a particular edge of a
cell should be ruled or not. Even this additional complexity doesn't provide
enough rendering control to meet the full range of needs for tables. The
current specification deliberately sticks to a simple intuitive model,
sufficient for most purposes. Further experimental work is needed before a more
complex approach is standardized.</p>

<h4>Row and column groups<a name="h-B.5.1.4">&nbsp;</a></h4>

<p>This specification provides a superset of the simpler model presented in
earlier work on HTML+. Tables are considered as being formed from an optional
caption together with a sequence of rows, which in turn consist of a sequence
of table cells. The model further differentiates header and data cells, and
allows cells to span multiple rows and columns.</p>

<p>Following the CALS table model (see <a rel="biblioentry" href= 
"../references.html#ref-CALS" class="informref">[CALS]</a>), this specification
allows table rows to be grouped into head and body and foot sections. This
simplifies the representation of rendering information and can be used to
repeat table head and foot rows when breaking tables across page boundaries, or
to provide fixed headers above a scrollable body panel. In the markup, the foot
section is placed before the body sections. This is an optimization shared with
CALS for dealing with very long tables. It allows the foot to be rendered
without having to wait for the entire table to be processed.</p>

<h4>Accessibility<a name="h-B.5.1.5">&nbsp;</a></h4>

<p>For the visually impaired, HTML offers the hope of setting to rights the
damage caused by the adoption of windows based graphical user interfaces. The
HTML table model includes attributes for labeling each cell, to support high
quality text to speech conversion. The same attributes can also be used to
support automated import and export of table data to databases or
spreadsheets.</p>

<h3><a name="h-B.5.2">B.5.2</a> <span class="index-inst" title="table::layout 
algorithms for"><a name="layout">Recommended Layout Algorithms</a></span></h3>

<p>If <a href="../struct/tables.html#edef-COL" class="noxref"><samp class=
"einst">COL</samp></a> or <a href="../struct/tables.html#edef-COLGROUP" class= 
"noxref"><samp class="einst">COLGROUP</samp></a> elements are present, they
specify the number of columns and the table may be rendered using a fixed
layout. Otherwise the autolayout algorithm described below should be used.</p>

<p>If the <samp>width</samp> attribute is not specified, visual user agents
should assume a default value of <tt>100%</tt> for formatting.</p>

<p>It is recommended that user agents increase table widths beyond the value
specified by <samp>width</samp> in cases when cell contents would otherwise
overflow. User agents that override the specified width should do so within
reason. User agents may elect to split words across lines to avoid the need for
excessive horizontal scrolling or when such scrolling is impractical or
undesired.</p>

<p>For the purposes of layout, user agents should consider that table captions
(specified by the <a href="../struct/tables.html#edef-CAPTION" class="noxref">
<samp class="einst">CAPTION</samp></a> element) behave like cells. Each caption
is a cell that spans all of the table's columns if at the top or bottom of the
table, and rows if at the left or right side of the table.</p>

<h4>Fixed Layout Algorithm<a name="h-B.5.2.1">&nbsp;</a></h4>

<p>For this algorithm, it is assumed that the number of columns is known. The
column widths by default should be set to the same size. Authors may override
this by specifying relative or absolute column widths, using the <a href= 
"../struct/tables.html#edef-COLGROUP" class="noxref"><samp class="einst">
COLGROUP</samp></a> or <a href="../struct/tables.html#edef-COL" class="noxref">
<samp class="einst">COL</samp></a> elements. The default table width is the
space between the current left and right margins, but may be overridden by the
<a href="../struct/tables.html#adef-width-TABLE" class="noxref"><samp class= 
"ainst-TABLE">width</samp></a> attribute on the <a href= 
"../struct/tables.html#edef-TABLE" class="noxref"><samp class="einst">
TABLE</samp></a> element, or determined from absolute column widths. To deal
with mixtures of absolute and relative column widths, the first step is to
allocate space from the table width to columns with absolute widths. After
this, the space remaining is divided up between the columns with relative
widths.</p>

<p>The table syntax alone is insufficient to guarantee the consistency of
attribute values. For instance, the number of <a href= 
"../struct/tables.html#edef-COL" class="noxref"><samp class="einst">
COL</samp></a> and <a href="../struct/tables.html#edef-COLGROUP" class=
"noxref"><samp class="einst">COLGROUP</samp></a> elements may be inconsistent
with the number of columns implied by the table cells. A further problem occurs
when the columns are too narrow to avoid overflow of cell contents. The width
of the table as specified by the <a href="../struct/tables.html#edef-TABLE"
class="noxref"><samp class="einst">TABLE</samp></a> element or <a href= 
"../struct/tables.html#edef-COL" class="noxref"><samp class="einst">
COL</samp></a> elements may result in overflow of cell contents. It is
recommended that user agents attempt to recover gracefully from these
situations, e.g., by <a href="../struct/text.html#hyphenation">hyphenating
words</a> and resorting to splitting words if hyphenation points are
unknown.</p>

<p>In the event that an indivisible element causes cell overflow, the user
agent may consider adjusting column widths and re-rendering the table. In the
worst case, clipping may be considered if column width adjustments and/or
scrollable cell content are not feasible. In any case, if cell content is split
or clipped this should be indicated to the user in an appropriate manner.</p>

<h4>Autolayout Algorithm<a name="h-B.5.2.2">&nbsp;</a></h4>

<p>If the number of columns is not specified with <a href= 
"../struct/tables.html#edef-COL" class="noxref"><samp class="einst">
COL</samp></a> and <a href="../struct/tables.html#edef-COLGROUP" class=
"noxref"><samp class="einst">COLGROUP</samp></a> elements, then the user agent
should use the following autolayout algorithm. It uses two passes through the
table data and scales linearly with the size of the table.</p>

<p>In the first pass, line wrapping is disabled, and the user agent keeps track
of the minimum and maximum width of each cell. The maximum width is given by
the widest line. Since line wrap has been disabled, paragraphs are treated as
long lines unless broken by <a href="../struct/text.html#edef-BR" class=
"noxref"><samp class="einst">BR</samp></a> elements. The minimum width is given
by the widest text element (word, image, etc.) taking into account leading
indents and list bullets, etc. In other words, it is necessary to determine the
minimum width a cell would require in a window of its own before the cell
begins to overflow. Allowing user agents to split words will minimize the need
for horizontal scrolling or in the worst case, clipping the cell contents.</p>

<p>This process also applies to any nested tables occurring in cell content.
The minimum and maximum widths for cells in nested tables are used to determine
the minimum and maximum widths for these tables and hence for the parent table
cell itself. The algorithm is linear with aggregate cell content, and broadly
speaking, independent of the depth of nesting.</p>

<p>To cope with character alignment of cell contents, the algorithm keeps three
running min/max totals for each column: Left of align char, right of align char
and unaligned. The minimum width for a column is then: <tt>max(min_left +
min_right, min_non-aligned)</tt>.</p>

<p>The minimum and maximum cell widths are then used to determine the
corresponding minimum and maximum widths for the columns. These in turn, are
used to find the minimum and maximum width for the table. Note that cells can
contain nested tables, but this doesn't complicate the code significantly. The
next step is to assign column widths according to the available space (i.e.,
the space between the current left and right margins).</p>

<p>For cells that span multiple columns, a simple approach consists of
apportioning the min/max widths evenly to each of the constituent columns. A
slightly more complex approach is to use the min/max widths of unspanned cells
to weight how spanned widths are apportioned. Experiments suggest that a blend
of the two approaches gives good results for a wide range of tables.</p>

<p>The table borders and intercell margins need to be included in assigning
column widths. There are three cases:</p>

<ol>
<li><b>The minimum table width is equal to or wider than the available
space.</b> In this case, assign the minimum widths and allow the user to scroll
horizontally. For conversion to braille, it will be necessary to replace the
cells by references to notes containing their full content. By convention these
appear before the table.</li>

<li><b>The maximum table width fits within the available space.</b> In this
case, set the columns to their maximum widths.</li>

<li><b>The maximum width of the table is greater than the available space, but
the minimum table width is smaller.</b> In this case, find the difference
between the available space and the minimum table width, lets call it <b>W</b>.
Lets also call <b>D</b> the difference between maximum and minimum width of the
table. 

<p>For each column, let <b>d</b> be the difference between maximum and minimum
width of that column. Now set the column's width to the minimum width plus <b>
d</b> times <b>W</b> over <b>D</b>. This makes columns with large differences
between minimum and maximum widths wider than columns with smaller
differences.</p>
</li>
</ol>

<p>This assignment step is then repeated for nested tables using the minimum
and maximum widths derived for all such tables in the first pass. In this case,
the width of the parent table cell plays the role of the current window size in
the above description. This process is repeated recursively for all nested
tables. The topmost table is then rendered using the assigned widths. Nested
tables are subsequently rendered as part of the parent table's cell
contents.</p>

<p>If the table width is specified with the <a href= 
"../struct/tables.html#adef-width-TABLE" class="noxref"><samp class=
"ainst-TABLE">width</samp></a> attribute, the user agent attempts to set column
widths to match. The <a href="../struct/tables.html#adef-width-TABLE" class= 
"noxref"><samp class="ainst-TABLE">width</samp></a> attribute is not binding if
this results in columns having less than their minimum (i.e., indivisible)
widths.</p>

<p>If relative widths are specified with the <a href= 
"../struct/tables.html#edef-COL" class="noxref"><samp class="einst">
COL</samp></a> element, the algorithm is modified to increase column widths
over the minimum width to meet the relative width constraints. The <a href= 
"../struct/tables.html#edef-COL" class="noxref"><samp class="einst">
COL</samp></a> elements should be taken as hints only, so columns shouldn't be
set to less than their minimum width. Similarly, columns shouldn't be made so
wide that the table stretches well beyond the extent of the window. If a <a
href="../struct/tables.html#edef-COL" class="noxref"><samp class="einst">
COL</samp></a> element specifies a relative width of zero, the column should
always be set to its minimum width.</p>

<p>When using the two pass layout algorithm, the default alignment position in
the absence of an explicit or inherited <a href= 
"../struct/tables.html#adef-charoff" class="noxref"><samp class="ainst">
charoff</samp></a> attribute can be determined by choosing the position that
would center lines for which the widths before and after the alignment
character are at the maximum values for any of the lines in the column for
which <tt>align="char"</tt>. For incremental table layout the suggested default
is <tt>charoff="50%"</tt>. If several cells in different rows for the same
column use character alignment, then by default, all such cells should line up,
regardless of which character is used for alignment. Rules for handling objects
too large for a column apply when the explicit or implied alignment results in
a situation where the data exceeds the assigned width of the column.</p>

<div class="note">
<p><em><strong>Choice of attribute names.</strong> It would have been
preferable to choose values for the <a href="../struct/tables.html#adef-frame"
class="noxref"><samp class="ainst-TABLE">frame</samp></a> attribute consistent
with the <a href="../struct/tables.html#adef-rules" class="noxref"><samp class= 
"ainst-TABLE">rules</samp></a> attribute and the values used for alignment. For
instance: <tt>none, top, bottom, topbot, left, right, leftright, all</tt>.
Unfortunately, SGML requires enumerated attribute values to be unique for each
element, independent of the attribute name. This causes immediate problems for
"none", "left", "right" and "all". The values for the <a href= 
"../struct/tables.html#adef-frame" class="noxref"><samp class="ainst-TABLE">
frame</samp></a> attribute have been chosen to avoid clashes with the <a href= 
"../struct/tables.html#adef-rules" class="noxref"><samp class="ainst-TABLE">
rules</samp></a>, <a href="../struct/tables.html#adef-align-TABLE" class=
"noxref"><samp class="ainst-TABLE">align</samp></a>, and <a href= 
"../struct/tables.html#adef-valign" class="noxref"><samp class="ainst">
valign</samp></a> attributes. This provides a measure of future proofing, as it
is anticipated that the <a href="../struct/tables.html#adef-frame" class=
"noxref"><samp class="ainst">frame</samp></a> and <a href= 
"../struct/tables.html#adef-rules" class="noxref"><samp class="ainst">
rules</samp></a> attributes will be added to other table elements in future
revisions to this specification. An alternative would be to make <a href= 
"../struct/tables.html#adef-frame" class="noxref"><samp class="ainst-TABLE">
frame</samp></a> a CDATA attribute. The consensus of the W3C HTML Working Group
was that the benefits of being able to use SGML validation tools to check
attributes based on enumerated values outweighs the need for consistent
names.</em></p>
</div>

<h2><a name="h-B.6">B.6</a> <span class="index-inst" title="form::display
notes"><a name="notes-forms">Notes on forms</a></span></h2>

<h3><a name="h-B.6.1">B.6.1</a> Incremental display</h3>

<p>The incremental display of documents being received from the network gives
rise to certain problems with respect to forms. User agents should prevent
forms from being submitted until all of the form's elements have been
received.</p>

<p>The incremental display of documents raises some issues with respect to
tabbing navigation. The heuristic of giving focus to the lowest valued <a href= 
"../interact/forms.html#adef-tabindex" class="noxref"><samp class="ainst">
tabindex</samp></a> in the document seems reasonable enough at first glance.
However this implies having to wait until all of the document's text is
received, since until then, the lowest valued <a href= 
"../interact/forms.html#adef-tabindex" class="noxref"><samp class="ainst">
tabindex</samp></a> may still change. If the user hits the tab key before then,
it is reasonable for user agents to move the focus to the lowest currently
available <a href="../interact/forms.html#adef-tabindex" class="noxref"><samp
class="ainst">tabindex</samp></a>.</p>

<p>If forms are associated with client-side scripts, there is further potential
for problems. For instance, a script handler for a given field may refer to a
field that doesn't yet exist.</p>

<h3><a name="h-B.6.2">B.6.2</a> Future projects</h3>

<p>This specification defines a set of elements and attributes powerful enough
to fulfill the general need for producing forms. However there is still room
for many possible improvements. For instance the following problems could be
addressed in the future:</p>

<ul>
<li>The range of form field types is too limited in comparison with modern user
interfaces. For instance there is no provision for tabular data entry, sliders
or multiple page layouts.</li>

<li>Servers cannot update the fields in a submitted form and instead have to
send a complete HTML document causing screen flicker.</li>

<li>These also cause problems for speech based browsers, making it difficult
for the visually impaired to interact with HTML forms.</li>
</ul>

<p>Another possible extension would be to add the <a href= 
"../struct/objects.html#adef-usemap" class="noxref"><samp class="ainst">
usemap</samp></a> attribute to <a href="../interact/forms.html#edef-INPUT"
class="noxref"><samp class="einst">INPUT</samp></a> for use as client-side
image map when "<a href="../interact/forms.html#adef-type-INPUT" class=
"noxref"><samp class="ainst-INPUT">type</samp></a>=image". The <a href= 
"../struct/objects.html#edef-AREA" class="noxref"><samp class="einst">
AREA</samp></a> element corresponding to the location clicked would contribute
the value to be passed to the server. To avoid the need to modify server
scripts, it may be appropriate to extend <a href= 
"../struct/objects.html#edef-AREA" class="noxref"><samp class="einst">
AREA</samp></a> to provide x and y values for use with the <a href= 
"../interact/forms.html#edef-INPUT" class="noxref"><samp class="einst">
INPUT</samp></a> element.</p>

<h2><a name="h-B.7">B.7</a> <span class="index-inst" title= 
"script::implementation notes"><a name="notes-scripting">Notes on
scripting</a></span></h2>

<h3><a name="h-B.7.1">B.7.1</a> <span class="index-inst" title= 
"script::reserved syntax for"><a name="idx-script-1">Reserved syntax for future
script macros</a></span></h3>

<p>This specification reserves syntax for the future support of script macros
in HTML CDATA attributes. The intention is to allow attributes to be set
depending on the properties of objects that appear earlier on the page. The
syntax is:</p>

<pre>
   attribute = "... &amp;{ <i>macro body</i> }; ... "
</pre>

<h4>Current Practice for Script Macros<a name="h-B.7.1.1">&nbsp;</a></h4>

<p>The macro body is made up of one or more statements in the default scripting
language (as per intrinsic event attributes). The semicolon following the right
brace is always needed, as otherwise the right brace character "}" is treated
as being part of the macro body. Its also worth noting that quote marks are
always needed for attributes containing script macros.</p>

<p>The processing of CDATA attributes proceeds as follows:</p>

<ol>
<li>The SGML parser evaluates any SGML entities (e.g., "&amp;gt;").</li>

<li>Next the script macros are evaluated by the script engine.</li>

<li>Finally the resultant character string is passed to the application for
subsequent processing.</li>
</ol>

<p>Macro processing takes place when the document is loaded (or reloaded) but
does not take place again when the document is resized, repainted, etc.</p>

<div class="deprecated-example">
<p><span class="example-title">DEPRECATED EXAMPLE:</span>
<br>
Here are some examples using JavaScript. The first one randomizes the document
background color:</p>

<pre>
    
&lt;BODY bgcolor='&amp;{randomrgb};'&gt;
</pre>

<p>Perhaps you want to dim the background for evening viewing:</p>

<pre>
    
&lt;BODY bgcolor='&amp;{if(Date.getHours &gt; 18)...};'&gt;
</pre>

<p>The next example uses JavaScript to set the coordinates for a client-side
image map:</p>

<pre>
    
&lt;MAP NAME=foo&gt;
   &lt;AREA shape="rect" coords="&amp;{myrect(imageuri)};" href="&amp;{myuri};" alt=""&gt;
 &lt;/MAP&gt;
</pre>

<p>This example sets the size of an image based upon document properties:</p>

<pre>
    
&lt;IMG src="bar.gif" width='&amp;{document.banner.width/2};' height='50%' alt="banner"&gt;
</pre>

<p>You can set the URI for a link or image by script:</p>

<pre>
 &lt;SCRIPT type="text/javascript"&gt;
   function manufacturer(widget) {
       ...
   }
   function location(manufacturer) {
       ...
   }
   function logo(manufacturer) {
       ...
   }
 &lt;/SCRIPT&gt;
  &lt;A href='&amp;{location(manufacturer("widget"))};'&gt;widget&lt;/A&gt;
  &lt;IMG src='&amp;{logo(manufacturer("widget"))};' alt="logo"&gt;
</pre>

<p>This last example shows how SGML CDATA attributes can be quoted using single
or double quote marks. If you use single quotes around the attribute string
then you can include double quote marks as part of the attribute string.
Another approach is use &amp;quot; for double quote marks:</p>

<pre>
   
&lt;IMG src="&amp;{logo(manufacturer(&amp;quot;widget&amp;quot;))};" alt="logo"&gt;
</pre>
</div>

<h2><a name="h-B.8">B.8</a> <a name="notes-frames">Notes on frames</a></h2>

<p>Since there is no guarantee that a frame target name is unique, it is
appropriate to describe the current practice in finding a <span class= 
"index-inst" title="frame::target algorithm|target frame::algorithm"><a name= 
"idx-frame">frame given a target name</a></span>:</p>

<ol>
<li>If the target name is a reserved word as described in the normative text,
apply it as described.</li>

<li>Otherwise, perform a depth-first search of the frame hierarchy in the
window that contained the link. Use the first frame whose name is an exact
match.</li>

<li>If no such frame was found in (2), apply step 2 to each window, in a
front-to-back ordering. Stop as soon as you encounter a frame with exactly the
same name.</li>

<li>If no such frame was found in (3), create a new window and assign it the
target name.</li>
</ol>

<h2><a name="h-B.9">B.9</a> <a name="accessibility">Notes on
accessibility</a></h2>

<p>The W3C Web Accessibility Initiative (<a href=
"../references.html#ref-WAI">[WAI]</a>) is producing a series of guidelines to
improve Web accessibility for people with disabilities. There are three sets of
guidelines:</p>

<ul>
<li>Web Content Accessibility Guidelines (<a rel="biblioentry" href= 
"../references.html#ref-WCGL" class="informref">[WCGL]</a>), for authors and
site managers. Please consult the Web Content Accessibility Guidelines for
information about supplying alternative text for images, applets, scripts,
etc.</li>

<li>User Agent Accessibility Guidelines (<a rel="biblioentry" href= 
"../references.html#ref-UAGL" class="informref">[UAGL]</a>), for user agent
developers (browsers, multimedia players, assistive technologies). Please
consult these guidelines for guidance on handling alternate text.</li>

<li>Authoring Tool Accessibility Guidelines (<a rel="biblioentry" href= 
"../references.html#ref-ATGL" class="informref">[ATGL]</a>), for authoring tool
developers.</li>
</ul>

<h2><a name="h-B.10">B.10</a> <span class="index-inst" title="security::notes 
on|"><a name="notes-security">Notes on security</a></span></h2>

<p>Anchors, embedded images, and all other elements that contain <a href= 
"../types.html#type-uri">URIs</a> as parameters may cause the URI to be
dereferenced in response to user input. In this case, the security issues of <a
rel="biblioentry" href="../references.html#ref-RFC1738" class="normref">
[RFC1738]</a>, section 6, should be considered. The widely deployed methods for
submitting form requests -- HTTP and SMTP -- provide little assurance of
confidentiality. Information providers who request sensitive information via
forms -- especially with the <a href="../interact/forms.html#edef-INPUT" class= 
"noxref"><samp class="einst">INPUT</samp></a> element, <a href= 
"../interact/forms.html#adef-type-INPUT" class="noxref"><samp class=
"ainst-INPUT">type</samp></a>="password" -- should be aware and make their
users aware of the lack of confidentiality.</p>

<h3><a name="h-B.10.1">B.10.1</a> <a name="forms-security">Security issues for
forms</a></h3>

<p>A user agent should not send any file that the user has not explicitly asked
to be sent. Thus, HTML user agents are expected to confirm any default file
names that might be suggested by the <a href= 
"../interact/forms.html#adef-value-INPUT" class="noxref"><samp class= 
"ainst-INPUT">value</samp></a> attribute of the <a href= 
"../interact/forms.html#edef-INPUT" class="noxref"><samp class="einst">
INPUT</samp></a> element. Hidden controls must not specify files.</p>

<p>This specification does not contain a mechanism for encryption of the data;
this should be handled by whatever other mechanisms are in place for secure
transmission of data.</p>

<p>Once a file is uploaded, the processing agent should process and store it
appropriately.</p>

<div class="navbar" align="center">
<hr><a href="changes.html">previous</a> &nbsp; <a href="../references.html">
next</a> &nbsp; <a href="../cover.html#minitoc">contents</a> &nbsp; <a href= 
"../index/elements.html">elements</a> &nbsp; <a href=
"../index/attributes.html">attributes</a> &nbsp; <a href="../index/list.html">
index</a></div>
</body>
</html>

