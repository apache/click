/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.click.examples.page.tree;

import org.apache.click.examples.page.BorderPage;
import org.apache.click.extras.tree.Tree;
import org.apache.click.extras.tree.TreeNode;

/**
 * Example usage of the {@link Tree} control.
 */
public class TreePage extends BorderPage {

    private static final long serialVersionUID = 1L;

    public static final String TREE_NODES_SESSION_KEY = "treeNodes";

    protected Tree tree;

    // Event Handlers ---------------------------------------------------------

    /**
     * @see org.apache.click.Page#onInit()
     */
    @Override
    public void onInit() {
        super.onInit();

        //Create the tree and tree model and add it to the page
        tree = buildTree();
        addControl(tree);
    }

    /**
     * @see org.apache.click.Page#onGet()
     */
    @Override
    public void onGet() {
        String selectId = getContext().getRequestParameter(Tree.SELECT_TREE_NODE_PARAM);
        String expandId = getContext().getRequestParameter(Tree.EXPAND_TREE_NODE_PARAM);
        if(selectId == null && expandId == null) {
            return;
        }

        TreeNode node = null;
        if(selectId != null) {
            node = tree.find(selectId);
        } else {
            node = tree.find(expandId);
        }
        addModel("treeNode", node);
    }

    // Protected Methods ------------------------------------------------------

    /**
     * Creates and return a new tree instance.
     */
    protected Tree createTree() {
        return new Tree("tree");
    }

    /**
     * Build the tree and tree nodes and store the nodes in the session.
     */
    protected Tree buildTree() {
        tree = createTree();

        //Try and load the already stored nodes from the session.
        //If this is the first time we access the page, this method
        //will return null, indicating no nodes is stored.
        TreeNode existingRootNode = loadNodesFromSession();

        if(existingRootNode != null) {
            //OK we had already nodes stored in the session, so no need
            //to rebuild them. We attach the root node and return.
            tree.setRootNode(existingRootNode);

            //By default root node is not displayed in browser. Here we expand it,
            //so that the root's children are visible.
            tree.expand(existingRootNode);
            return tree;
        }

        TreeNode root = createNodes();

        //Attach the root node containing all the other nodes to the tree
        tree.setRootNode(root);

        //By default root node is not displayed in browser. Here we expand it,
        //so that the root's children are visible.
        tree.expand(root);

        //Store the tree nodes in the session so on the next request we do not
        //have to rebuild it. Also because we keep the tree nodes in the session
        //the nodes will keep their state between requests.
        storeNodesInSession(root);

        return tree;
    }

    /**
     * Create the tree nodes. The nodes represents a directory consisting of
     * files and folders as found on an Operating System.
     *
     * @return the root tree node
     */
    protected TreeNode createNodes() {

        //Create a node representing the root directory with the specified
        //parameter as the value. Because an id is not specified, a random
        //one will be generated by the node. By default the root node is
        //not rendered by the tree. This can be changed by calling
        //tree.setRootNodeDisplayed(true).
        TreeNode root = new TreeNode("c:");

        //Create a new directory, setting the root directory as its parent. Here
        //we do specify a id as the 2nd argument, so no id is generated.
        TreeNode dev = new TreeNode("dev","1");
        root.add(dev);

        //The following 3 nodes represent files in the directory as children of
        // the dev node. Note the false argument to the constructor.
        // This means that the specific node does not support child nodes, and
        // it will be rendered as a leaf icon. If children are supported (the
        // default value) then even  if the node is a leaf, it will still be rendered
        // as a collapsed icon. In the example a default leaf node will be
        // rendered as a directory, and a node that does not support children is
        // rendered as a file.
        // Also note the node with the long text, will cause the tree to overflow
        // and add scrollbars
        dev.add(new TreeNode("java.pdf", "1.1", false));
        dev.add(new TreeNode("JEE 6 - the new fantastic approach to write better software (apparently)", "1.2", false));
        dev.add(new TreeNode("ruby.pdf", "1.3", false));

        //We continue constructing the rest of the tree
        TreeNode programFiles = new TreeNode("program files", "2");
        root.add(programFiles);
        programFiles.add(new TreeNode("Adobe", "2.1"));

        TreeNode download = new TreeNode("downloads","3");
        root.add(download);

        TreeNode web = new TreeNode("web", "3.1");
        download.add(web);
        web.add(new TreeNode("html.pdf", "3.1.1", false));
        web.add(new TreeNode("css.html", "3.1.2", false));

        TreeNode databases = new TreeNode("databases", "3.2");
        download.add(databases);
        TreeNode relationalDb = new TreeNode("relational", "3.2.1");
        databases.add(relationalDb);

        relationalDb.add(new TreeNode("mysql.html", "3.2.1.1", false));
        relationalDb.add(new TreeNode("oracle.pdf", "3.2.1.2", false));
        relationalDb.add(new TreeNode("postgres", "3.2.1.3", false));

        TreeNode objectDb = new TreeNode("object", "3.2.2");
        databases.add(objectDb);
        objectDb.add(new TreeNode("db4o.html", "3.2.2.1", false));

        return root;
    }

    /**
     * Return the string under which the nodes are stored in the session.
     *
     * @return the string under which the nodes are stored in the session
     */
    protected String getSessionKey() {
        return TREE_NODES_SESSION_KEY;
    }

    /**
     * Store the tree nodes in the session
     */
    protected void storeNodesInSession(TreeNode rootNode) {
        if (tree.getRootNode() == null) {
            return;
        }

        getContext().getSession().setAttribute(getSessionKey(), rootNode);
    }

    /**
     * Retrieve the tree nodes from the session if available. Otherwise we return
     * null.
     */
    protected TreeNode loadNodesFromSession() {
        return (TreeNode) getContext().getSession().getAttribute(getSessionKey());
    }
}
